Introduction

This document explains the key Git concepts  push, rebase, fast-forward, and merge  using practical commands, 

real-world analogies and recommended workflows. It is intended as a reference for QA engineers and developers who wish to understand when and 

how to use each operation safely and effectively.

1. Git Push

Short definition: git push uploads commits from your local repository to a remote repository (for example GitHub).

Analogy:
Your local repository is your private draft notebook. The remote repository is the public library shelf. 

git push places your latest draft onto the shelf so others may read it.

Common commands:

# Push current branch to the remote 'origin'
git push origin my-branch

# Push and set upstream (useful on first push)
git push -u origin my-branch


Behaviour & notes:

git push only transmits commits  it does not push uncommitted changes.

If the remote branch contains commits you don’t have locally, push will be rejected; Git asks you to pull or reconcile first.

In many team workflows you should push feature branches and create a Pull Request (PR) rather than pushing directly to main/master.

Best practice:

Use descriptive branch names (feature/shadow-dom-asaph, bugfix/login-404).

Push frequently on feature branches; keep main protected.

2. Git Merge

Short definition: git merge integrates changes from one branch into another, preserving the history of both branches.

Analogy:
Merging is like combining two separate drafts into a single book while keeping both authors’ edit histories intact.

Commands:

# On branch 'main', merge 'feature' into it
git checkout main
git merge feature


Types of merges:

Automatic merge (no conflicts): Git creates a merge commit that ties the two histories together.

Merge conflict: When the same lines of a file were edited differently, Git stops and asks you to resolve conflicts manually, 

then git add the resolved files and git commit.

When to use merge:

When you want to preserve the full history of both branches.

In team environments where the PR/merge model is preferred  it is explicit and easy to review.

Best practice:

Keep merges small and frequent to reduce the risk of conflicts.

Use descriptive merge commits (if not auto-generated by PR systems).

3. Fast-Forward Merge

Short definition: A fast-forward merge happens when the target branch has not advanced since you created your feature branch. Git simply moves the target branch pointer forward to your branch tip  there is no merge commit.

Analogy:

Walking along a straight path. There is no branching or joining; you simply move forward to the new point.

When it occurs:

You branch from main, make commits on feature, and nobody else has committed to main. Merging feature into main will fast-forward.

Command that produces a fast-forward:

git checkout main
git merge feature   # may produce fast-forward if possible


To prevent fast-forward (force a merge commit):

git merge --no-ff feature


Use this when you want an explicit merge commit for the feature for historical clarity.

Best practice:

Use fast-forward for small, single-developer changes.

Use --no-ff in teams if you want each feature to have its own merge commit for traceability.

4. Git Rebase

Short definition: git rebase moves (reapplies) your commits on top of another base commit. 

It rewrites history to make it appear as if your work was made after the branch you rebased onto.

Analogy:

Imagine editing chapters of a book. Rebase is like picking up your chapter drafts and placing them after the latest edition of 

the book so the narrative reads as a single, linear flow.

Commands:

# Rebase current branch on top of main
git checkout feature
git fetch origin
git rebase origin/main

# If there are conflicts, resolve, then continue:
git add <file>
git rebase --continue
# If you want to abort the rebase:
git rebase --abort


Rebase vs Merge  quick comparison:

Rebase produces a linear history; it rewrites commits.

Merge preserves the exact historical branching and produces merge commits.

Use rebase to keep history tidy on feature branches before merging; use merge to preserve shared history.

Interactive rebase (powerful):

git rebase -i origin/main


This allows you to:

Squash commits

Reword commit messages

Drop commits

Reorder commits

When to use rebase:

To tidy up your local commit history before opening a PR.

To bring a feature branch up to date with the latest main while keeping a linear history.

When not to rebase:

Never rebase public/shared branches that others use  rewriting published history will cause problems for collaborators.

Avoid rebasing main or other remote-tracked branches.

Best practice:

Rebase local feature work onto remote main before merging via PR.

Use git pull --rebase to fetch and rebase in one step (keeps your local commits on top).

5. Squash Commits (a rebase pattern)

Short definition: Squashing combines multiple commits into a single commit.

Analogy:

You had many small scratch edits; squashing packages them into a single, polished commit ready for review.

Command (interactive rebase):

git rebase -i HEAD~4
# Mark commits to squash (s) or fixup (f)


Why squash?

Makes PRs easier to review.

Keeps the main history concise.

6. Typical Workflows & Examples
A. Feature Branch Workflow (recommended)

Create a branch:

git checkout -b feature/your-feature


Work and commit locally:

git add .
git commit -m "Implement X"


Keep your branch up to date:

git fetch origin
git rebase origin/main   # *preferred* for linear history
# or git merge origin/main


Push and create a PR:

git push -u origin feature/your-feature


Create PR, request reviews, merge via protected branch rules.

B. Hotfix Workflow

Branch from main:

git checkout main
git pull
git checkout -b hotfix/urgent-fix


Fix, commit, and push:

git add .
git commit -m "Fix critical bug"
git push origin hotfix/urgent-fix


Merge hotfix into main and then merge main into develop (if using Git Flow) or rebase other branches.

7. Conflict Resolution  Practical Steps

When rebase or merge reports a conflict:

Open the file(s) with conflicts. You’ll see conflict markers:

<<<<<<< HEAD
// Current branch code
=======
// Incoming branch code
>>>>>>> feature


Edit to create the desired content; remove markers.

Stage the resolved file:

git add path/to/file


Continue:

For merge: git commit (if necessary)

For rebase: git rebase --continue

If things go wrong: git rebase --abort or git merge --abort to return to the prior state.

Tip: Use git status and git diff to inspect changes. A GUI (VS Code, GitKraken) also helps.

8. Safety Tips & Good Habits

Never rewrite public history: don’t rebase published branches. If you must, coordinate with the team.

Use feature branches: keep main stable and protected.

Small commits & descriptive messages: each commit should represent a single, logical change.

Pull with rebase on local branches:

git config --global pull.rebase true


Avoid git push --force unless you know exactly what you are doing and you are the only one using the branch. 

Prefer git push --force-with-lease which is safer:

git push --force-with-lease origin your-branch


Use protected branches on remote (require PRs, reviews, CI passing).

9. Useful Commands & Shortcuts
# Create & switch to branch
git checkout -b feature/name

# List branches
git branch
git branch -r   # remote
git branch -a   # all

# Switch to a branch
git checkout main
# or modern:
git switch main

# Fetch remote updates
git fetch origin

# Rebase current branch onto origin/main
git rebase origin/main

# Merge a branch into current
git merge feature/name

# Push branch and set upstream
git push -u origin feature/name

# Force push (cautious)
git push --force-with-lease origin feature/name

# Interactive rebase last N commits
git rebase -i HEAD~N

# Abort rebase
git rebase --abort

# View log graph
git log --oneline --graph --all --decorate

10. Example Scenarios  What to Do When
Scenario A  You developed on a feature branch and main moved forward:

Goal: Incorporate latest main changes cleanly.

git fetch origin
git rebase origin/main        # preferred for clean history
# resolve conflicts if any
git push --force-with-lease   # only if you rebased

Scenario B  Your branch is shared and you want to integrate main:
git fetch origin
git merge origin/main         # safer for shared branches
git push

Scenario C  The remote rejects your push because remote changed:
git pull --rebase origin main    # rebase your changes on top of remote
# resolve conflicts, then:
git push

11. CI/CD & Pull Request Considerations

Configure branch protection (require PR reviews, passing CI).

Prefer merges via PR UI (many teams use squash-and-merge or merge commit policies).

Use git rebase locally to tidy commits before opening a PR.

Ensure tests run in CI before allowing merge.

12. Final Notes  Philosophy & When to Use What

Use merge when you want to preserve the branch topology and history explicitly (team transparency).

Use rebase to keep your feature branch history neat, before publishing or making a PR.

Fast-forward is fine for trivial updates when no one else has worked on main.

Squash when many small commits should be presented as a single logical change.

Appendix  Short Cheat Sheet (Copy-Paste)
# Create branch and switch
git checkout -b feature/xyz

# Keep branch up to date (rebase method)
git fetch origin
git rebase origin/main

# Resolve conflicts, then:
git rebase --continue

# Push branch to origin
git push -u origin feature/xyz

# If you rebased and need to update remote branch
git push --force-with-lease origin feature/xyz

# Merge branch into main
git checkout main
git merge feature/xyz

# Fast-forward only if possible:
git merge --ff-only feature/xyz

# Interactive rebase (squash/reword)
git rebase -i HEAD~4
